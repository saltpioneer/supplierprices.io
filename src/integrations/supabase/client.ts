// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';

// Clean env inputs in case quotes/semicolons/spaces were added in .env.local
const clean = (v?: string) => (v ?? "")
  .trim()
  .replace(/^['"`]+/, "")
  .replace(/['"`]+$/, "")
  .replace(/;+\s*$/, "")
  .trim();

const SUPABASE_URL = clean(import.meta.env.VITE_SUPABASE_URL as string);
const SUPABASE_PUBLISHABLE_KEY = clean(import.meta.env.VITE_SUPABASE_ANON_KEY as string);

// Debug logging to help diagnose env issues
// eslint-disable-next-line no-console
console.log("Raw env URL:", import.meta.env.VITE_SUPABASE_URL);
// eslint-disable-next-line no-console
console.log("Cleaned URL:", SUPABASE_URL);

if (!/^https?:\/\//i.test(SUPABASE_URL)) {
  // eslint-disable-next-line no-console
  console.error("Invalid VITE_SUPABASE_URL:", SUPABASE_URL);
}
if (!SUPABASE_PUBLISHABLE_KEY) {
  // eslint-disable-next-line no-console
  console.error("Missing VITE_SUPABASE_ANON_KEY env value");
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create a mock client if credentials are missing to prevent app crashes
const isValidUrl = /^https?:\/\//i.test(SUPABASE_URL);
const isValidKey = SUPABASE_PUBLISHABLE_KEY && SUPABASE_PUBLISHABLE_KEY !== "placeholder_key";

export const supabase = isValidUrl && isValidKey 
  ? createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        storage: localStorage,
        persistSession: true,
        autoRefreshToken: true,
      }
    })
  : (() => {
      // Robust mock client to prevent crashes when credentials are missing
      const promiseResult = { data: [], error: null, count: 0 } as const;
      const createBuilder = () => {
        const builder: any = {
          select: () => builder,
          order: () => builder,
          eq: () => builder,
          ilike: () => builder,
          limit: () => builder,
          then: (onFulfilled: any, onRejected?: any) => Promise.resolve(promiseResult).then(onFulfilled, onRejected),
        };
        return builder;
      };

      return {
        from: () => ({
          select: () => createBuilder(),
          insert: () => Promise.resolve(promiseResult),
          update: () => Promise.resolve(promiseResult),
          delete: () => Promise.resolve(promiseResult),
        }),
        auth: {
          signIn: () => Promise.resolve({ data: null, error: null }),
          signOut: () => Promise.resolve({ error: null }),
          getUser: () => Promise.resolve({ data: null, error: null }),
        }
      } as const;
    })();